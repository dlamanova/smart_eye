# Copilot instructions for SmartEye (smart_eye)

Purpose: give an AI coding agent quick, actionable knowledge to be productive in this Flutter app.

1. Project snapshot (big picture)

- Flutter mobile app (lib/) with a small MVC-ish split: `lib/screens` (UI), `lib/controllers` (ChangeNotifier controllers), `lib/services` (backend/integration), `lib/models` (domain models), and `lib/core` (app wiring + Firebase options + theme).
- State & DI: services are created in `main.dart` and injected via `Provider`/`ChangeNotifierProvider` (see `lib/main.dart`).
- WebRTC/video streaming uses a Janus gateway: signaling handling is in `lib/services/janus_service.dart` and the UI glue is in `lib/controllers/device_stream_controller.dart`.

2. How the main data flows work (short)

- Auth + Firestore: `lib/services/firebase_service.dart` (auth, device CRUD, notifications). Firestore document paths use the pattern `artifacts/{appId}/users/{userId}/...` for private data and `artifacts/{appId}/public/data/webrtc_sessions/{sessionId}` for WebRTC signaling.
- Video: App connects to Janus via HTTP (long-polling). Janus messages are exposed as a broadcast Stream `JanusService.janusResponses` and consumed by `DeviceStreamController` to handle offers, answers and trickle candidates.
- Routing: Monitoring pages are created with a route like `/monitoring/<deviceId>` and the `DeviceStreamController` is constructed in `onGenerateRoute` so it is scoped to that screen.

3. Project-specific conventions and patterns

- Services are not singletons via global locator; they are created in `main.dart` then provided via `Provider.value(...)` and read with `Provider.of<T>(context, listen: false)`.
- Controllers extend `ChangeNotifier` and expose getters for UI; controllers are provided to a screen using `ChangeNotifierProvider(create: (_) => DeviceStreamController(...))`.
- WebRTC handling: prefer manipulating SDP to favor codecs (see `_preferCodec` in `lib/controllers/device_stream_controller.dart`).
- Firestore paths: the code expects an `appId` inside `FirebaseService` and stores both public (webrtc_sessions) and private (users/\*/devices) data under `artifacts/{appId}`.

4. Integration points & external dependencies to be aware of

- Firebase: `lib/core/firebase_options.dart` (generated by FlutterFire CLI) is used to initialize Firebase in `main.dart`. Do not delete/regenerate unless you know the project Firebase setup.
- Janus Gateway: configured in `lib/services/janus_service.dart` (default `http://192.168.1.11:8088/janus` and a hard-coded token). This is environment-specific and often needs updating for different dev machines.
- Plugins: `flutter_webrtc`, `cloud_firestore`, `firebase_auth`, `firebase_messaging`, `mqtt_client` and others in `pubspec.yaml`.

5. Common developer workflows (commands and verification)

- Install deps: `flutter pub get` in project root (`smart_eye/`).
- Run app: `flutter run -d <device>` (or open with your IDE). For iOS ensure CocoaPods are installed: `cd ios && pod install` if you edit native pods.
- Tests: `flutter test` (unit/widget tests live under `test/` if present).
- Build: `flutter build apk` or `flutter build ios` (follow Apple signing steps for iOS).
- Linting/spec: uses `flutter_lints` in `pubspec.yaml`.

6. Key files to inspect for specific behaviors (examples)

- Routing & DI: `lib/main.dart` (service creation and onGenerateRoute for monitoring routes).
- WebRTC glue: `lib/controllers/device_stream_controller.dart` — look at `_startWebRTCSession`, the `janusResponses` listener, and `_preferCodec` for codec tweaks.
- Janus comms: `lib/services/janus_service.dart` — connect(), attachAsPublisher(), subscribeToFeed(), sendAnswer(), sendTrickleCandidate(), and the `janusResponses` Stream.
- Firestore & auth: `lib/services/firebase_service.dart` — device CRUD, `streamUserDevices()` and `streamDevice()` and `updateDeviceState()` used by controllers.
- Firebase CLI config: `lib/core/firebase_options.dart` (generated) — used by `Firebase.initializeApp(...)` in `main.dart`.

7. Gotchas and safety notes (from repo scan)

- Network & secrets: Janus URL and token are hard-coded inside `lib/services/janus_service.dart`. Firebase options are present in `lib/core/firebase_options.dart`. Treat these as environment-specific and sensitive; prefer using environment overrides for production.
- Long-running async: controllers create network/listener subscriptions (see `DeviceStreamController`). Ensure proper disposal — the code marks `_isDisposed` and cancels subscriptions; follow that pattern when adding listeners.
- SDP / codec handling: the app force-prefers H264 via SDP reordering. If you change codecs, test on actual devices/emulators.

8. How to extend safely (quick contract)

- Inputs: add services in `main.dart` and provide them via `Provider` so controllers/screens can take them via constructor.
- Outputs: controllers expose plain data via getters and call `notifyListeners()` after state changes.
- Error handling: UI surfaces `_errorMessage` from controllers; follow the pattern in `DeviceStreamController` when adding network/error flows.

If anything above is unclear or you want more details (e.g., where native config files live, CI steps, or to remove hard-coded tokens), tell me which area to expand and I will iterate.
